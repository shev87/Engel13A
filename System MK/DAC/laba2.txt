#include "Header.h"

#define SIGNAL_DELAY 240 /// 30 мкс
#define SIGNAL_DELAY1 160 /// 20 мкс
#define SIGNAL_DELAY2 80 /// 10 мкс
/// Можно определить маску для работы с нужными битами
#define DIG_OUT_MASK  ((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2))

void init_DAC( void )
{  ///////////////////////////
  DDRB |= (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2);
  PORTB = (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2);

}

#define CLK_BIT  (1<<PB5)
#define DAC_PORT  PORTB
#define CS  (1<<PB5)
#define LD  (1<<PB5)

void CLK( void ) ///Тип void задает пустое множество ///////////////////////////////значений. Он используется для
///////////////////////////////обозначения типа функций, которые ///////////////////////////////не возвращают результат.
{
  DAC_PORT &= ~CLK_BIT; ///инверсия - сбрасывание в 0
  DAC_PORT |= CLK_BIT; /// или - установка в 1
}

void write_DAC( u_int data )
{

  DAC_PORT &= ~CS;

while(1){

  for(int i=0; i<12 ; i++){
     PORTB = (0<<PB5);
     CLK();

     __delay_cycles(SIGNAL_DELAY);

  }

    PORTB = (1<<PB5);

     __delay_cycles(SIGNAL_DELAY);
}
__delay_cycles(SIGNAL_DELAY1);

  DAC_PORT |= CS;
  __delay_cycles(SIGNAL_DELAY2);
  DAC_PORT &= ~LD;
  DAC_PORT |= LD;

}

void main( void )
{
  /// включим подтяжку на всех выводах МК
   PORTB = 0xFF;
   PORTC = 0xFF;
   PORTD = 0xFF;
  ///////////////////////////
  DDRB |= (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2);
  PORTB = (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2);

}






