#include "DAC_iface.h"


// Процедура настройки таймера 0
void init_Timer_0(void)
{
  TCCR0 = (1<<CS01)|(1<<CS00);  // Timer Clock = system clock / 64
  // сбросим флаг переполнения если установлен
  TIFR  = 1<<TOV0;		// Clear TOV0 / Clear pending interrupts
  // разрешаем прерывания от события переполнение таймера 0
  TIMSK = 1<<TOIE0;             // Enable Timer 0 Overflow Interrupt
}

int data_2_OUT;
/// определим длинну массива - количество выборок в массиве
#define SIGNAL_ARR_SIZE     5
/// ступенчатый сигнал величина ступени 1В
int flash SIGNAL_ARR[SIGNAL_ARR_SIZE] = {
  0, 1000, 2000, 3000, 4000
};
///// определим длинну массива - количество выборок в массиве
//#define SIGNAL_ARR_SIZE     33
///// половина синуса
//int flash SIGNAL_ARR[SIGNAL_ARR_SIZE] = {
//0,      392,      781,      1161,     1531,
//1886,   2223,     2538,     2829,     3093,
//3326,   3528,     3696,     3828,     3923,
//3981,   4000,     3981,     3923,     3827,
//3695,   3527,     3325,     3091,     2827,
//2536,   2220,     1883,     1528,     1158,
//777,    389,      0
//};

int index; /// переменная для перебора значений массива

// процедура прерывания по переполнению таймера Т0...
#pragma vector=TIMER0_OVF_vect
__interrupt void Timer_0_ovfEVENT(void)
{
  /// формирование на выходе ЦАП табличной функции
  u_int itmp;
  /// если дошли до конца массива...
  if(index >= SIGNAL_ARR_SIZE)
     index = 0;             /// сброс индекса

  itmp = SIGNAL_ARR[index]; /// читаем значение из массива
  DAC_Write(itmp);          /// запись данных в ЦАП DAC7611
  index++;                  /// переходим к следующему значению

  /// формирование пилообразного напряжения на выходе ЦАП
  ///DAC_Write(data_2_OUT);/// запись данных в ЦАП DAC7611
  ///data_2_OUT++;
}

void main( void )
{
  /// включим подтяжку на всех выводах МК
   PORTB = 0xFF;
   PORTC = 0xFF;
   PORTD = 0xFF;

   data_2_OUT = 0;
   index = 0;
   /// настройка интерфейса для работы с ЦАП
   Init_DAC_Iface();

   // Процедура настройки таймера 0
   init_Timer_0();

   /// разрешаем прерывания
   _SEI();

  ///////////////////////////
  /// основной цикл
  while(1){
    _NOP();/// команда nop ничего не делаем
  }
}
