##############################################################################
#                                                                            #
#                                                      07/May/2008  11:43:11 #
# IAR Atmel AVR C/C++ Compiler V4.20A/W32, Evaluation Version                #
# Copyright 1996-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC_ #
#                    UART\main_uart_rem.c                                    #
#    Command line =  "E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC #
#                    _UART\main_uart_rem.c" --cpu=m8 -ms -o "E:\Рабочая      #
#                    програсса РЭА (образец)\LABORATOR_WORKS\ADC_UART\Debug\ #
#                    Obj\" -lC "E:\Рабочая програсса РЭА                     #
#                    (образец)\LABORATOR_WORKS\ADC_UART\Debug\List\" -lA     #
#                    "E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC #
#                    _UART\Debug\List\" --initializers_in_flash -z9          #
#                    --cross_call_passes=4 --debug -DENABLE_BIT_DEFINITIONS  #
#                    --do_cross_call -e -I "C:\Program Files\IAR             #
#                    Systems\Embedded Workbench 4.0 Evaluation\avr\INC\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 4.0    #
#                    Evaluation\avr\INC\CLIB\" --eeprom_size 512             #
#    List file    =  E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC_ #
#                    UART\Debug\List\main_uart_rem.lst                       #
#    Object file  =  E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC_ #
#                    UART\Debug\Obj\main_uart_rem.r90                        #
#                                                                            #
#                                                                            #
##############################################################################

E:\Рабочая програсса РЭА (образец)\LABORATOR_WORKS\ADC_UART\main_uart_rem.c
      1          /*! \file *******************************************************************
      2          *
      3          * По  материалам application notes адаптируем на mega8
      4          *
      5          * AppNote           : AVR121 - Enhancing ADC resolution by oversampling
      6          *
      7          * Description       : Example of how to use oversampling to increase the resolution.
      8          *                     10-bit result is written to UART after each conversion
      9          *                     16-bit result are written to UART after 4096 10-bit samples
     10          *
     11          ****************************************************************************/
     12          #include "Header.h"

   \                                 In segment ABSOLUTE, at 0x24
   \   union <unnamed> volatile __io _A_ADC
   \                     _A_ADC:
   \   00000000                      DS 2

   \                                 In segment ABSOLUTE, at 0x26
   \   union <unnamed> volatile __io _A_ADCSR
   \                     _A_ADCSR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x27
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_UBRRL
   \                     _A_UBRRL:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_UCSRB
   \                     _A_UCSRB:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSRA
   \                     _A_UCSRA:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR
   \                     _A_UDR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_UBRRH
   \                     _A_UBRRH:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x43
   \   union <unnamed> volatile __io _A_OCR2
   \                     _A_OCR2:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x45
   \   union <unnamed> volatile __io _A_TCCR2
   \                     _A_TCCR2:
   \   00000000                      DS 1
     13          #include "FLOAT2ASCII.h"
     14          
     15          // Global variables

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     16          float accumulator       = 0;          //!< Accumulating 10-bit samples
   \                     accumulator:
   \   00000000                      DS 4
     17          float result            = 0;          //!< ASCII variable
     18          float Vin               = 0;          //!< 16-bit result
   \                     Vin:
   \   00000004                      DS 4
     19          short temp              = 0;          //!< последнее измеренное значение ADC
   \                     temp:
   \   00000008                      DS 2
     20          short samples           = 0;	      //!< Counting 10-bit samples
   \                     samples:
   \   0000000A                      DS 2

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     result:
   \   00000000                      DS 4
     21          /// длина буффера строки для передачи ПК
     22          #define BUFF_LEN  128
     23          /// буффер в который записываем нужную информацию для передачи ПК

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     24          char Str_Buff[BUFF_LEN];
   \                     Str_Buff:
   \   00000000                      DS 128
     25          
     26          
     27          // Function prototypes
     28          void send(unsigned char result);
     29          void write_ascii(char *Ptr2Str);
     30          void init_adc(void);
     31          void init_uart(void);
     32          void init_counter(void);
     33          void vin(void);
     34          void write_10bit(void);
     35          void write_16bit(void);
     36          void oversampled(void);
     37          void write_space(void);
     38          
     39          //! ADC interrupt routine
     40          #pragma vector=ADC_vect

   \                                 In segment CODE, align 2, keep-with-next
     41          __interrupt void ADCinterrupt(void)
   \                     ADCinterrupt:
     42          {
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   938A               ST      -Y, R24
   \   0000000A   93FA               ST      -Y, R31
   \   0000000C   93EA               ST      -Y, R30
   \   0000000E   923A               ST      -Y, R3
   \   00000010   922A               ST      -Y, R2
   \   00000012   921A               ST      -Y, R1
   \   00000014   920A               ST      -Y, R0
   \   00000016   937A               ST      -Y, R23
   \   00000018   936A               ST      -Y, R22
   \   0000001A   935A               ST      -Y, R21
   \   0000001C   934A               ST      -Y, R20
   \   0000001E   933A               ST      -Y, R19
   \   00000020   932A               ST      -Y, R18
   \   00000022   931A               ST      -Y, R17
   \   00000024   930A               ST      -Y, R16
   \   00000026   B78F               IN      R24, 0x3F
   \   00000028                      REQUIRE ?Register_R6_is_cg_reg
   \   00000028                      REQUIRE ?Register_R7_is_cg_reg
     43            temp = ADC;        
   \   00000028   ....               LDI     R26, LOW(accumulator)
   \   0000002A   ....               LDI     R27, (accumulator) >> 8
   \   0000002C   B104               IN      R16, 0x04
   \   0000002E   B115               IN      R17, 0x05
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8700               STD     Z+8, R16
   \   00000034   8711               STD     Z+9, R17
     44            accumulator += ADC;
   \   00000036   914D               LD      R20, X+
   \   00000038   915D               LD      R21, X+
   \   0000003A   916D               LD      R22, X+
   \   0000003C   917C               LD      R23, X
   \   0000003E   9713               SBIW    R27:R26, 3
   \   00000040   013B               MOVW    R7:R6, R23:R22
   \   00000042   B104               IN      R16, 0x04
   \   00000044   B115               IN      R17, 0x05
   \   00000046   E020               LDI     R18, 0
   \   00000048   E030               LDI     R19, 0
   \   0000004A   ....               RCALL   ?UL2F_L04
   \   0000004C   01B3               MOVW    R23:R22, R7:R6
   \   0000004E   ....               RCALL   ?Subroutine0
     45            samples++;
   \                     ??CrossCallReturnLabel_0:
   \   00000050   01FD               MOVW    R31:R30, R27:R26
   \   00000052   8502               LDD     R16, Z+10
   \   00000054   8513               LDD     R17, Z+11
   \   00000056   5F0F               SUBI    R16, 255
   \   00000058   4F1F               SBCI    R17, 255
   \   0000005A   8702               STD     Z+10, R16
   \   0000005C   8713               STD     Z+11, R17
     46          }
   \   0000005E   BF8F               OUT     0x3F, R24
   \   00000060   9109               LD      R16, Y+
   \   00000062   9119               LD      R17, Y+
   \   00000064   9129               LD      R18, Y+
   \   00000066   9139               LD      R19, Y+
   \   00000068   9149               LD      R20, Y+
   \   0000006A   9159               LD      R21, Y+
   \   0000006C   9169               LD      R22, Y+
   \   0000006E   9179               LD      R23, Y+
   \   00000070   9009               LD      R0, Y+
   \   00000072   9019               LD      R1, Y+
   \   00000074   9029               LD      R2, Y+
   \   00000076   9039               LD      R3, Y+
   \   00000078   91E9               LD      R30, Y+
   \   0000007A   91F9               LD      R31, Y+
   \   0000007C   9189               LD      R24, Y+
   \   0000007E   91A9               LD      R26, Y+
   \   00000080   91B9               LD      R27, Y+
   \   00000082   9069               LD      R6, Y+
   \   00000084   9079               LD      R7, Y+
   \   00000086   9518               RETI

   \                                 In segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   ....               RCALL   ?F_ADD_L04
   \                     ??Subroutine0_0:
   \   00000002   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_9:
   \   00000004   9713               SBIW    R27:R26, 3
   \   00000006   9508               RET

   \                                 In segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   930D               ST      X+, R16
   \   00000002   931D               ST      X+, R17
   \   00000004   932D               ST      X+, R18
   \   00000006   933C               ST      X, R19
   \   00000008   9508               RET
     47          
     48          //! Enables ADC, Interrupt enabled, ADC-clock=125kHz, VREF=AREF

   \                                 In segment CODE, align 2, keep-with-next
     49          void init_adc(void)
   \                     init_adc:
     50          {
     51            ADCSR = (1<<ADEN)|(1<<ADIE)|(1<<ADSC)|(1<<ADFR)|(1<<ADPS2)|(1<<ADPS1);
   \   00000000   EE0E               LDI     R16, 238
   \   00000002   B906               OUT     0x06, R16
     52            ADMUX = (0<<REFS1)|(1<<REFS0); /// 11 - 2,56В 01 - AVCC
   \   00000004   E400               LDI     R16, 64
   \   00000006   B907               OUT     0x07, R16
     53            __enable_interrupt();
   \   00000008   9478               SEI
     54          }
   \   0000000A   9508               RET
     55          
     56          /*! \brief Initiates the UART, 19.2kbps @ 8MHz cpu-clk.,
     57               enables transmitter, 8 data, 1 stop, no parity
     58               transmitting 8 LSB */

   \                                 In segment CODE, align 2, keep-with-next
     59          void init_uart(void)
   \                     init_uart:
     60          {
     61             /// Set baud rate
     62             UBRRH = (unsigned char)(_UART_BAUD>>8);
   \   00000000   E000               LDI     R16, 0
   \   00000002   BD00               OUT     0x20, R16
     63             UBRRL = (unsigned char)_UART_BAUD;
   \   00000004   E109               LDI     R16, 25
   \   00000006   B909               OUT     0x09, R16
     64             /// Enable Receiver and Transmitter
     65             UCSRB = (1<<TXEN);
   \   00000008   E008               LDI     R16, 8
   \   0000000A   B90A               OUT     0x0A, R16
     66             /// Set frame format: 8data, 1stop bit
     67             UCSRC = (1<<URSEL)|(0<<USBS)|(3<<UCSZ0);
   \   0000000C   E806               LDI     R16, 134
   \   0000000E   BD00               OUT     0x20, R16
     68          }
   \   00000010   9508               RET
     69          
     70          //! Waits for empty transmit buffer, puts data into buffer and send data

   \                                 In segment CODE, align 2, keep-with-next
     71          void send(unsigned char result)
   \                     send:
   \                     ??send_0:
     72          {
     73            while (!(UCSRA & (1<<UDRE)));	
   \   00000000   9B5D               SBIS    0x0B, 0x05
   \   00000002   CFFE               RJMP    ??send_0
     74            UDR = result;         	             					
   \   00000004   B90C               OUT     0x0C, R16
     75          }
   \   00000006   9508               RET
     76          
     77          //! Fast PWM, Clk / 64, Clear OC2 on compare match, 50% duty cycle

   \                                 In segment CODE, align 2, keep-with-next
     78          void init_counter(void)
   \                     init_counter:
     79          {
     80            DDRD  = (1<<PD7);
   \   00000000   E800               LDI     R16, 128
   \   00000002   BB01               OUT     0x11, R16
     81            TCCR2 = (1<<WGM20)|(1<<WGM21)|(1<<COM21)|(1<<CS22);
   \   00000004   E60C               LDI     R16, 108
   \   00000006   BD05               OUT     0x25, R16
     82            OCR2  = 128;
   \   00000008   E800               LDI     R16, 128
   \   0000000A   BD03               OUT     0x23, R16
     83          }
   \   0000000C   9508               RET
     84          
     85          ////////////////////////////////////////
     86          /// передаем строку в ПК 
     87          /// строка всегда завершается 0 что бы определить конец строки

   \                                 In segment CODE, align 2, keep-with-next
     88          void write_ascii(char *Ptr2Str)
   \                     write_ascii:
     89          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
     90            char* In_BufPtr = Ptr2Str;  /// указатель на текущий символ для передачи
   \   00000002   01D8               MOVW    R27:R26, R17:R16
     91            char countr = 0;  /// счетчик переданных символов
   \   00000004   E080               LDI     R24, 0
     92          
     93            /// если выходим за пределы буффера - конец передачи
     94            while ( countr < BUFF_LEN )
     95            {
     96              char symb = *In_BufPtr++;  
   \                     ??write_ascii_0:
   \   00000006   910D               LD      R16, X+
     97              if(symb == 0) break;  /// встретили конец строки завершаем передачу
   \   00000008   2300               TST     R16
   \   0000000A   F021               BREQ    ??write_ascii_1
     98              send(symb);           /// передаем очередной байт из буффера
   \   0000000C   ....               RCALL   send
     99              countr++;
   \   0000000E   9583               INC     R24
    100            }
   \   00000010   3880               CPI     R24, 128
   \   00000012   F3C8               BRCS    ??write_ascii_0
    101            send('\r');             /// Send return
   \                     ??write_ascii_1:
   \   00000014   E00D               LDI     R16, 13
   \   00000016   ....               RCALL   send
    102            send('\n');             /// Send newline
   \   00000018   E00A               LDI     R16, 10
   \   0000001A   ....               RCALL   send
    103          }
   \   0000001C   ....               RJMP    ?Subroutine4

   \                                 In segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   E0E4               LDI     R30, 4
   \   00000002   ....               RJMP    ?EPILOGUE_B4_L09
    104          
    105          //! Calculating 16-bit result

   \                                 In segment CODE, align 2, keep-with-next
    106          void vin(void)
   \                     vin:
    107          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
    108            Vin = (accumulator/65536)*5.0;	     // VREF = 4.910
   \   00000002   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00000004   913D               LD      R19, X+
   \   00000006   ....               RCALL   ??Subroutine2_0
   \                     ??CrossCallReturnLabel_5:
   \   00000008   E477               LDI     R23, 71
   \   0000000A   ....               RCALL   ?F_DIV_L04
   \   0000000C   E040               LDI     R20, 0
   \   0000000E   E050               LDI     R21, 0
   \   00000010   EA60               LDI     R22, 160
   \   00000012   E470               LDI     R23, 64
   \   00000014   ....               RCALL   ?F_MUL_L04
   \   00000016   ....               RCALL   ?Subroutine3
    109          }
   \                     ??CrossCallReturnLabel_8:
   \   00000018   ....               RJMP    ?Subroutine4

   \                                 In segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   9713               SBIW    R27:R26, 3
   \                     ??Subroutine2_0:
   \   00000002   E040               LDI     R20, 0
   \   00000004   E050               LDI     R21, 0
   \   00000006   E860               LDI     R22, 128
   \   00000008   9508               RET

   \                                 In segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   ....               LDI     R26, LOW(accumulator)
   \   00000002   ....               LDI     R27, (accumulator) >> 8
   \   00000004   910D               LD      R16, X+
   \   00000006   911D               LD      R17, X+
   \   00000008   912D               LD      R18, X+
   \   0000000A   9508               RET
    110          
    111          //// подготовка данных для передачи ПК в буффере
    112          /// в буффер записываем код ADC и вычисленное значение 

   \                                 In segment CODE, align 2, keep-with-next
    113          void write_data_2Buffer(void)
   \                     write_data_2Buffer:
    114          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
    115            /// заполним буффер символами '_'
    116            memset(Str_Buff, '_', BUFF_LEN);
   \   00000002   ....               LDI     R26, LOW(Str_Buff)
   \   00000004   ....               LDI     R27, (Str_Buff) >> 8
   \   00000006   E840               LDI     R20, 128
   \   00000008   E050               LDI     R21, 0
   \   0000000A   E52F               LDI     R18, 95
   \   0000000C   E030               LDI     R19, 0
   \   0000000E   018D               MOVW    R17:R16, R27:R26
   \   00000010   ....               RCALL   memset
    117            Str_Buff[0] = 'A';
   \   00000012   E401               LDI     R16, 65
   \   00000014   930C               ST      X, R16
    118            Str_Buff[1] = 'D';
   \   00000016   E404               LDI     R16, 68
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   8301               STD     Z+1, R16
    119            Str_Buff[2] = 'C';
   \   0000001C   E403               LDI     R16, 67
   \   0000001E   8302               STD     Z+2, R16
    120            Str_Buff[3] = '=';
   \   00000020   E30D               LDI     R16, 61
   \   00000022   8303               STD     Z+3, R16
    121            /// запишет 8 байт в буффер начиная с 5 байта
    122            BSD_FP((float)temp, &Str_Buff[4]);
   \   00000024   ....               LDI     R24, LOW(accumulator)
   \   00000026   ....               LDI     R25, (accumulator) >> 8
   \   00000028   01AD               MOVW    R21:R20, R27:R26
   \   0000002A   5F4C               SUBI    R20, 252
   \   0000002C   4F5F               SBCI    R21, 255
   \   0000002E   01FC               MOVW    R31:R30, R25:R24
   \   00000030   8500               LDD     R16, Z+8
   \   00000032   8511               LDD     R17, Z+9
   \   00000034   2F21               MOV     R18, R17
   \   00000036   0F22               LSL     R18
   \   00000038   0B22               SBC     R18, R18
   \   0000003A   2F32               MOV     R19, R18
   \   0000003C   ....               RCALL   ?SL2F_L04
   \   0000003E   ....               RCALL   BSD_FP
    123            /// (4+8 = 12)
    124            Str_Buff[12] = ' ';
   \   00000040   E200               LDI     R16, 32
   \   00000042   01FD               MOVW    R31:R30, R27:R26
   \   00000044   8704               STD     Z+12, R16
    125            Str_Buff[13] = 'a';
   \   00000046   E601               LDI     R16, 97
   \   00000048   8705               STD     Z+13, R16
    126            Str_Buff[14] = 'c';
   \   0000004A   E603               LDI     R16, 99
   \   0000004C   8706               STD     Z+14, R16
    127            Str_Buff[15] = 'c';
   \   0000004E   8707               STD     Z+15, R16
    128            Str_Buff[16] = '=';
   \   00000050   E30D               LDI     R16, 61
   \   00000052   8B00               STD     Z+16, R16
    129            /// запишет 8 байт в буффер начиная с 17 байта
    130            BSD_FP(accumulator, &Str_Buff[17]);
   \   00000054   01AD               MOVW    R21:R20, R27:R26
   \   00000056   5E4F               SUBI    R20, 239
   \   00000058   4F5F               SBCI    R21, 255
   \   0000005A   01FC               MOVW    R31:R30, R25:R24
   \   0000005C   8100               LD      R16, Z
   \   0000005E   8111               LDD     R17, Z+1
   \   00000060   8122               LDD     R18, Z+2
   \   00000062   8133               LDD     R19, Z+3
   \   00000064   ....               RCALL   BSD_FP
    131            Str_Buff[25] = 0;  // конец строки
   \   00000066   E000               LDI     R16, 0
   \   00000068   01FD               MOVW    R31:R30, R27:R26
   \   0000006A   8F01               STD     Z+25, R16
    132          }
   \   0000006C                      REQUIRE ?Subroutine4
   \   0000006C                      ;               // Fall through to label ?Subroutine4
    133          
    134          /*! \brief Compensate errors, scaling result, round up,
    135              increase averaged result */

   \                                 In segment CODE, align 2, keep-with-next
    136          void oversampled(void)
   \                     oversampled:
    137          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
    138            u_int itmp;
    139            __disable_interrupt();
   \   00000002   94F8               CLI
    140            accumulator += 0;       // Offset error compensation, 5150 = (69*4096)/64*/
    141            itmp=(int)accumulator%64;
   \   00000004   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   00000006   913C               LD      R19, X
   \   00000008   9713               SBIW    R27:R26, 3
   \   0000000A   ....               RCALL   ?F2L_L04
   \   0000000C   E440               LDI     R20, 64
   \   0000000E   E050               LDI     R21, 0
   \   00000010   ....               RCALL   ?SS_DIVMOD_L02
   \   00000012   01CA               MOVW    R25:R24, R21:R20
    142            accumulator/=64;
   \   00000014   910D               LD      R16, X+
   \   00000016   911D               LD      R17, X+
   \   00000018   912D               LD      R18, X+
   \   0000001A   913C               LD      R19, X
   \   0000001C   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_6:
   \   0000001E   E472               LDI     R23, 66
   \   00000020   ....               RCALL   ?F_DIV_L04
   \   00000022   ....               RCALL   ??Subroutine0_0
    143            if(itmp>=32)
   \                     ??CrossCallReturnLabel_1:
   \   00000024   3280               CPI     R24, 32
   \   00000026   4090               SBCI    R25, 0
   \   00000028   F020               BRCS    ??CrossCallReturnLabel_2
    144              {
    145                accumulator += 1;   //  Rounding up
   \   0000002A   9613               ADIW    R27:R26, 3
   \   0000002C   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   0000002E   E37F               LDI     R23, 63
   \   00000030   ....               RCALL   ?Subroutine0
    146              }
    147            ///accumulator *= 0.9993;     // Gain error compensation*/
    148          
    149            vin();
   \                     ??CrossCallReturnLabel_2:
   \   00000032   ....               RCALL   vin
    150            samples     = 0;			
   \   00000034   E000               LDI     R16, 0
   \   00000036   01FD               MOVW    R31:R30, R27:R26
   \   00000038   8702               STD     Z+10, R16
   \   0000003A   8703               STD     Z+11, R16
    151            accumulator = 0;			
   \   0000003C   930D               ST      X+, R16
   \   0000003E   930D               ST      X+, R16
   \   00000040   930D               ST      X+, R16
   \   00000042   930C               ST      X, R16
    152            //// подготовка данных для передачи ПК в буффере
    153            /// в буффер записываем код ADC и вычисленное значение 
    154            write_data_2Buffer();
   \   00000044   ....               RCALL   write_data_2Buffer
    155            /// передаем строку в ПК 
    156            /// строка всегда завершается 0 что бы определить конец строки
    157            write_ascii(Str_Buff);
   \   00000046   ....               LDI     R16, LOW(Str_Buff)
   \   00000048   ....               LDI     R17, (Str_Buff) >> 8
   \   0000004A   ....               RCALL   write_ascii
    158            __enable_interrupt();
   \   0000004C   9478               SEI
    159          }
   \   0000004E   ....               RJMP    ?Subroutine4
    160          

   \                                 In segment CODE, align 2, keep-with-next
    161          void main( void )
   \                     main:
    162          {
    163            init_uart();
   \   00000000   ....               RCALL   init_uart
    164            init_adc();
   \   00000002   ....               RCALL   init_adc
    165            //init_counter();
    166          
    167            while(1)
    168            {
    169              if(samples>4095)
   \                     ??main_0:
   \   00000004   9110....           LDS     R17, (accumulator + 11)
   \   00000008   3110               CPI     R17, 16
   \   0000000A   F3E4               BRLT    ??main_0
    170                {
    171                  oversampled();
   \   0000000C   ....               RCALL   oversampled
   \   0000000E   CFFA               RJMP    ??main_0
    172                }
    173            }
    174          }

   \                                 In segment INTVEC, offset 0x1c, root
   \                     `??ADCinterrupt??INTVEC 28`:
   \   0000001C   ....               RJMP    ADCinterrupt
    175          

   Maximum stack usage in bytes:

     Function                CSTACK RSTACK
     --------                ------ ------
     ADCinterrupt               21      4
     init_adc                    0      2
     init_counter                0      2
     init_uart                   0      2
     main                        0      2
       -> init_uart              0      2
       -> init_adc               0      2
       -> oversampled            0      2
     oversampled                 4      4
       -> vin                    4      2
       -> write_data_2Buffer     4      2
       -> write_ascii            4      2
     send                        0      2
     vin                         4      4
     write_ascii                 4      2
       -> send                   4      2
       -> send                   4      2
       -> send                   4      2
     write_data_2Buffer          4      4
       -> memset                 4      2
       -> BSD_FP                 4      2
       -> BSD_FP                 4      2


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_ADC                       2
     _A_ADCSR                     1
     _A_ADMUX                     1
     _A_UBRRL                     1
     _A_UCSRB                     1
     _A_UCSRA                     1
     _A_UDR                       1
     _A_DDRD                      1
     _A_UBRRH                     1
     _A_OCR2                      1
     _A_TCCR2                     1
     accumulator                 12
     result                       4
     Str_Buff                   128
     ADCinterrupt               136
     ?Subroutine0                 8
     ?Subroutine3                10
     init_adc                    12
     init_uart                   18
     ??send_0                     8
     init_counter                14
     write_ascii                 30
     ?Subroutine4                 4
     vin                         26
     ?Subroutine2                10
     ?Subroutine1                12
     write_data_2Buffer         108
     oversampled                 80
     main                        16
     ??ADCinterrupt??INTVEC 28    2
      Others                      6

 
  12 bytes in segment ABSOLUTE
 492 bytes in segment CODE
   6 bytes in segment INITTAB
   2 bytes in segment INTVEC
 144 bytes in segment NEAR_Z
 
 492 bytes of CODE memory (+  8 bytes shared)
 144 bytes of DATA memory (+ 12 bytes shared)

Errors: none
Warnings: none
